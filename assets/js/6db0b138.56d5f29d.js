"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[333],{3752:(e,n,t)=>{t.d(n,{A:()=>i});var s=t(6540),a=t(4848);function i(e){let{src:n,options:t={}}=e;const i=(0,s.useRef)(null),[r,c]=(0,s.useState)(!1);return(0,s.useEffect)((()=>{if("undefined"==typeof window)return;const e="asciinema-player-css";if(!document.getElementById(e)){const n=document.createElement("link");n.id=e,n.rel="stylesheet",n.href="https://cdn.jsdelivr.net/npm/@asciinema/player@3.0.0/dist/themes/asciinema-player.css",document.head.appendChild(n)}const s="asciinema-player-script";let a=document.getElementById(s);a||(a=document.createElement("script"),a.id=s,a.src="https://cdn.jsdelivr.net/npm/@asciinema/player@3.0.0/dist/asciinema-player.min.js",a.async=!0,document.body.appendChild(a));const r=()=>{if(!window.AsciinemaPlayer)return void console.error("AsciinemaPlayer not available");const e=n.startsWith("http")?n:`${window.location.origin}${n}`;try{window.AsciinemaPlayer.create(e,i.current,{cols:120,rows:24,autoPlay:!0,fit:"width",...t}),c(!0)}catch(s){console.error("Player initialization failed:",s)}};return window.AsciinemaPlayer?r():a.onload=r,()=>{i.current&&(i.current.innerHTML="")}}),[n,t]),(0,a.jsx)("div",{ref:i,style:{minHeight:"300px",backgroundColor:r?"transparent":"#f5f5f5",borderRadius:"4px",margin:"20px 0",position:"relative"},children:!r&&(0,a.jsx)("div",{style:{position:"absolute",top:"50%",left:"50%",transform:"translate(-50%, -50%)",color:"#666"},children:"Loading player..."})})}},5363:(e,n,t)=>{t.d(n,{A:()=>i});t(6540);var s=t(9136),a=t(4848);function i(e){let{children:n,fallback:t}=e;return(0,s.A)()?(0,a.jsx)(a.Fragment,{children:n?.()}):t??null}},6202:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>u});const s=JSON.parse('{"id":"capabilities/async/backtrace","title":"Async backtrace","description":"async backtrace command overview","source":"@site/docs/capabilities/async/backtrace.mdx","sourceDirName":"capabilities/async","slug":"/capabilities/async/backtrace","permalink":"/BugStalker/docs/capabilities/async/backtrace","draft":false,"unlisted":false,"editUrl":"https://github.com/godzie44/BugStalker/tree/master/website/docs/capabilities/async/backtrace.mdx","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1,"description":"async backtrace command overview"},"sidebar":"tutorialSidebar","previous":{"title":"Async","permalink":"/BugStalker/docs/category/async"},"next":{"title":"Async steps","permalink":"/BugStalker/docs/capabilities/async/steps"}}');var a=t(4848),i=t(8453),r=t(5363),c=t(3752);const o={sidebar_position:1,description:"async backtrace command overview"},l="Async backtrace",d={},u=[{value:"Usage example",id:"usage-example",level:2}];function h(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"async-backtrace",children:"Async backtrace"})}),"\n",(0,a.jsx)(n.p,{children:"When debugging an asynchronous application, you often need to inspect and control its state.\nIn a regular synchronous application, you could simply use the backtrace command.\nHowever, this command provides limited utility for applications running on an asynchronous runtime."}),"\n",(0,a.jsx)(n.p,{children:'To address this, BugStalker introduces a suite of "asynchronous backtrace" commands.\nThese commands give you visibility into your asynchronous runtime\'s state, including:'}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"the status of asynchronous workers and blocking threads"}),"\n",(0,a.jsx)(n.li,{children:"Detailed information about each task in the system"}),"\n",(0,a.jsx)(n.li,{children:"each task's current state and its own backtrace - represented as a stack of futures from the root"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Available commands:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"async backtrace"})," (alias: ",(0,a.jsx)(n.code,{children:"async bt"}),") - Displays information about Tokio async workers and blocking threads, including:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"worker/blocking thread IDs"}),"\n",(0,a.jsx)(n.li,{children:"worker local task queue information"}),"\n",(0,a.jsx)(n.li,{children:"currently executing tasks for each worker"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"async backtrace all"})," (alias: ",(0,a.jsx)(n.code,{children:"async bt all"}),") - similar to the above, but includes information about all tasks in the system.\nEach task is represented with:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"a unique ID"}),"\n",(0,a.jsx)(n.li,{children:"a futures stack showing the chain of dependencies (where one future awaits another)"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"async task <regex>"})," - prints all tasks with root async functions whose names match the given regular expression.\nIf no regex is provided, displays active tasks"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"usage-example",children:"Usage example"}),"\n",(0,a.jsxs)(n.p,{children:["Consider this Rust program implementing a TCP echo server using ",(0,a.jsx)(n.code,{children:"tokio"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'#[tokio::main(worker_threads = 3)]\nasync fn main() -> Result<(), Box<dyn Error>> {\n    let addr = env::args()\n        .nth(1)\n        .unwrap_or_else(|| "127.0.0.1:8080".to_string());\n\n    let listener = TcpListener::bind(&addr).await?;\n    println!("Listening on: {}", addr);\n\n    loop {\n        let (mut socket, _) = listener.accept().await?;\n\n        tokio::spawn(async move {\n            let mut buf = vec![0; 1024];\n\n            loop {\n                let n = socket\n                    .read(&mut buf)\n                    .await\n                    .expect("failed to read data from socket");\n                if n == 0 {\n                    return;\n                }\n\n                let (tx, rx) = tokio::sync::oneshot::channel();\n                tokio::spawn(async move {\n                    tokio::time::sleep(Duration::from_secs(20)).await;\n                    tx.send(1).unwrap();\n                });\n\n                tokio::time::sleep(Duration::from_secs(5)).await;\n                _ = rx.await;\n\n                socket\n                    .write_all(&buf[0..n])\n                    .await\n                    .expect("failed to write data to socket");\n            }\n        });\n    }\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["To examine the state of asynchronous execution, lets set a breakpoint at the line ",(0,a.jsx)(n.code,{children:"tokio::time::sleep(Duration::from_secs(5)).await;"}),":"]}),"\n","\n",(0,a.jsx)(r.A,{children:()=>(0,a.jsx)(c.A,{src:"/BugStalker/casts/async_bt.cast"})})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>c});var s=t(6540);const a={},i=s.createContext(a);function r(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);